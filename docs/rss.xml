<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Nobody_Cares</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io</link><description>个人博客</description><copyright>Nobody_Cares</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/110390930?u=e650bc80688d9b64f5c5dd69d6cf9e822186493e&amp;v=4</url><title>avatar</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io</link></image><lastBuildDate>Sun, 19 Jan 2025 15:04:45 +0000</lastBuildDate><managingEditor>Nobody_Cares</managingEditor><ttl>60</ttl><webMaster>Nobody_Cares</webMaster><item><title>Java</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io/post/Java.html</link><description># Java
# 目录
&gt; [Java基础](#Java基础)
&gt; [面相对象编程](#面相对象编程)
&gt; 
## Java基础
### 1. Java基本结构
```Java
// 特殊的多行注释，以/**开头，以*/结束，如果有多行，每行通常以星号开头
/**
 * 可以用来自动创建文档的注释
 */
public class Hello {
    public static void main(String[] args) {
        // 向屏幕输出文本:
        System.out.println('Hello, world!');
        // 单行注释
        /* 多行注释开始
        注释内容
        注释结束 */
    }
} // class定义结束
```
&gt; Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。</description><guid isPermaLink="true">https://H-TXSL.github.io/Nobody_Cares.github.io/post/Java.html</guid><pubDate>Sun, 19 Jan 2025 15:04:21 +0000</pubDate></item><item><title>从零开始的STL生活</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io/post/cong-ling-kai-shi-de-STL-sheng-huo.html</link><description># 从零开始的STL生活&#13;
&gt; 参考[cppreference](https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5)&#13;
# 目录&#13;
&gt; - 序列&#13;
&gt; [array](#array)&#13;
&gt; [vector](#vector)&#13;
&gt; [迭代器图示](#迭代器图示)&#13;
## array&#13;
&gt; 头文件 `#include &lt;array&gt;`&#13;
***&#13;
&gt; - 成员函数&#13;
&gt;   - 成员访问&#13;
&gt; [at 带越界访问检查](#user-content-arr1)&#13;
&gt; [operator[] 访问指定元素, 无边界检查](#user-content-arr2)&#13;
&gt; [front 访问第一个元素](#user-content-arr3)&#13;
&gt; [back 访问最后一个元素](#user-content-arr4)&#13;
&gt; [data 直接访问底层连续存储](#user-content-arr5)&#13;
&gt;  - 迭代器&#13;
&gt;[迭代器](#user-content-arr6)&#13;
&gt;   - 容量&#13;
&gt; [empty 检查容器是否为空](#user-content-arr7)&#13;
&gt; [size 返回元素数](#user-content-arr8)&#13;
&gt; [max_size 返回可容纳的最大元素数](#user-content-arr9)&#13;
&gt; - 操作&#13;
&gt; [fill 以指定值填充容器](#user-content-arr10)&#13;
&gt; [swap 交换内容](#user-content-arr11)&#13;
&gt; - 非成员函数&#13;
&gt; [get(std::array) 访问 array 的一个元素](#user-content-arr12)&#13;
&gt; [std::swap(std::array) 特化 std::swap 算法](#user-content-arr13)&#13;
&gt; [std::to_array 从内建数组创建 std::array 对象](#user-content-arr14)&#13;
&gt; - 辅助类&#13;
&gt; [std::tuple_size\&lt;std::array&gt;](#user-content-arr15)&#13;
&gt; [std::tuple_element\&lt;std::array&gt;](#user-content-arr16)&#13;
***&#13;
- 成员访问&#13;
&lt;a name='arr1'&gt;&lt;/a&gt;&#13;
at 带越界访问检查&#13;
```c++&#13;
std::array&lt;int, 6&gt; arr{1, 2, 3, 4, 5, 6};&#13;
// 设置元素&#13;
arr.at(1) = 10;&#13;
// 访问元素&#13;
std::cout &lt;&lt; arr.at(1) &lt;&lt; std::endl; // 输出 10&#13;
// 越界则抛出 std::out_of_range 类型的异常&#13;
 try {&#13;
    arr.at(10) = 100;&#13;
  } catch (const std::out_of_range&amp; ex) {&#13;
    std::cout &lt;&lt; ex.what() &lt;&lt; std::endl; &#13;
  }&#13;
```&#13;
&lt;a name='arr2'&gt;&lt;/a&gt;&#13;
operator[] 访问指定元素, 无边界检查&#13;
```c++&#13;
std::array&lt;int, 6&gt; arr{1, 2, 3, 4, 5, 6};&#13;
// 设置元素&#13;
arr[1] = 10;&#13;
// 访问元素&#13;
std::cout &lt;&lt; arr[1] &lt;&lt; std::endl; // 输出 10&#13;
```&#13;
&#13;
&lt;a name='arr3'&gt;&lt;/a&gt;&#13;
front 访问第一个元素&#13;
```c++&#13;
std::array&lt;int, 6&gt; arr{1, 2, 3, 4, 5, 6};&#13;
// 访问第一个元素&#13;
std::cout &lt;&lt; arr.front() &lt;&lt; std::endl; // 输出 1&#13;
```&#13;
&#13;
&lt;a name='arr4'&gt;&lt;/a&gt;&#13;
back 访问最后一个元素&#13;
```c++&#13;
std::array&lt;int, 6&gt; arr{1, 2, 3, 4, 5, 6};&#13;
// 访问最后一个元素&#13;
std::cout &lt;&lt; arr.back() &lt;&lt; std::endl; // 输出 6&#13;
```&#13;
&#13;
&lt;a name='arr5'&gt;&lt;/a&gt;&#13;
data 直接访问底层连续存储&#13;
```c++&#13;
std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};&#13;
// 返回一个指向底层连续存储的指针&#13;
// 使得范围[data(), data() + size()]始终为有效范围&#13;
  int* p = arr.data();&#13;
  for (int i = 0; i &lt; arr.size(); i++)&#13;
  {&#13;
    std::cout &lt;&lt; *(p + i) &lt;&lt; ' ';&#13;
  }&#13;
  std::cout &lt;&lt; std::endl;&#13;
```&#13;
- 迭代器&#13;
&lt;a name='arr6'&gt;&lt;/a&gt;&#13;
begin 指向起始位置的迭代器 &#13;
end 指向末元素后一个位置的迭代器&#13;
rbegin 指向末元素的迭代器&#13;
rend 指向头元素前一个位置的迭代器&#13;
&gt; cbegin cend crbegin crend 为常量迭代器&#13;
```c++&#13;
  std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};&#13;
  // 正向迭代器&#13;
  for (auto it = arr.begin(); it != arr.end(); it++)&#13;
  {&#13;
    std::cout &lt;&lt; *it &lt;&lt; ' ';&#13;
    // 1 2 3 4 5 &#13;
  }&#13;
  std::cout &lt;&lt; std::endl;&#13;
  // 反向迭代器&#13;
  for (auto it = arr.rend() - 1; it != arr.rbegin() - 1; it--)&#13;
  {&#13;
    std::cout &lt;&lt; *it &lt;&lt; ' ';&#13;
    // 1 2 3 4 5 &#13;
  }&#13;
  std::cout &lt;&lt; std::endl;&#13;
```&#13;
- 容量&#13;
&lt;a name='arr7'&gt;&lt;/a&gt;&#13;
empty 检查容器是否为空&#13;
```c++&#13;
  std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};&#13;
  若容器为空则为 true，否则为 false&#13;
  std::cout &lt;&lt; std::boolalpha &lt;&lt; 'arr.empty() : ' &lt;&lt; arr.empty() &lt;&lt; std::endl;&#13;
  // arr.empty() : false&#13;
```&#13;
&lt;a name='arr8'&gt;&lt;/a&gt;&#13;
size 返回元素数&#13;
```c++&#13;
  std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};&#13;
  std::cout &lt;&lt; 'arr.size() : ' &lt;&lt; arr.size() &lt;&lt; std::endl;&#13;
  // arr.size() : 5&#13;
```&#13;
&lt;a name='arr9'&gt;&lt;/a&gt;&#13;
max_size 返回可容纳的最大元素数&#13;
```c++&#13;
  std::array&lt;int, 5&gt; arr{1, 2, 3, 4, 5};&#13;
  // 因为每个 std::array&lt;T, N&gt; 都是固定大小容器，故 max_size 返回的值等于 N（亦为 size() 所返回的值）。</description><guid isPermaLink="true">https://H-TXSL.github.io/Nobody_Cares.github.io/post/cong-ling-kai-shi-de-STL-sheng-huo.html</guid><pubDate>Thu, 31 Oct 2024 12:11:37 +0000</pubDate></item><item><title>C++文件操作</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io/post/C%2B%2B-wen-jian-cao-zuo.html</link><description>+ 所需头文件`#include &lt;fstream&gt;`&#13;
&#13;
&gt; 包含 fstream 类, ifstream 类, ofstream 类.  &#13;
fstream 读写&#13;
&gt;&#13;
&gt; ifstream 读&#13;
&gt;&#13;
&gt; ofstream 写&#13;
&gt;&#13;
&#13;
&#13;
&#13;
## 打开文件,没有此文件,则创建并打开&#13;
函数原型 `void open(const char* filename, ios_base::openmode mode);`&#13;
&#13;
filename 文件名	mode 打开模式&#13;
&#13;
&gt; 常见的打开模式&#13;
&gt;&#13;
&gt; std::ios::in：以只读模式打开文件。</description><guid isPermaLink="true">https://H-TXSL.github.io/Nobody_Cares.github.io/post/C%2B%2B-wen-jian-cao-zuo.html</guid><pubDate>Sat, 26 Oct 2024 19:54:09 +0000</pubDate></item><item><title>Markdown语法</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io/post/Markdown-yu-fa.html</link><description># Markdown语言&#13;
+ 提示: 适用与Github上的Markdown文本编辑&#13;
+ 在Github中的Markdown编辑器中,可以使用以下三种不同的语法在代码块中创建图表关系图：mermaid、geoJSON 和 topoJSON、ASCII STL.&#13;
[关于图表关系图请在此处查询](https://docs.github.com/zh/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams)&#13;
+ 在Github中的Markdown编辑器中支持LaTeX语法显示数学表达式.&#13;
[关于LaTeX语法请在此处查询](https://docs.github.com/zh/get-started/writing-on-github/working-with-advanced-formatting/writing-mathematical-expressions)&#13;
## 标题&#13;
- 创建标题&#13;
- 最大6个层次结构的标题&#13;
```Markdown&#13;
# 标题一&#13;
## 标题二&#13;
### 标题三&#13;
......&#13;
###### 标题六&#13;
```&#13;
# 标题一&#13;
## 标题二&#13;
### 标题三&#13;
......&#13;
###### 标题六&#13;
***&#13;
&lt;a name='set1'&gt;&lt;/a&gt;&#13;
&#13;
## 设置文本样式&#13;
| 语法 | 例子 | 输出 | &#13;
| :--: | :--: | :--: |&#13;
| ** **或者__ __ | `**粗体**` | **粗体** |&#13;
| * *或者_ _ | `*斜体*` | *斜体* |&#13;
| ~~ ~~ | `~~删除线~~` | ~~删除线~~ |&#13;
| ** ** 和 * * | `**粗体*斜体*字**` | **粗体*斜体*字**(粗体嵌套斜体) |&#13;
| * * 和 ** ** | `*斜体**粗体**字*` | *斜体**粗体**字*(斜体嵌套粗体) |&#13;
| *** *** | `***全部粗体加斜体***` | ***全部粗体加斜体*** |&#13;
| `&lt;sub&gt; &lt;/sub&gt;` | 这是一个`&lt;sub&gt;下标&lt;/sub&gt;` | 这是一个&lt;sub&gt;下标&lt;/sub&gt; |&#13;
| `&lt;sup&gt; &lt;/sup&gt;` | 这是一个`&lt;sup&gt;上标&lt;/sup&gt;` | 这是一个&lt;sup&gt;上标&lt;/sup&gt; |&#13;
&#13;
`***`代表分割线&#13;
***&#13;
空行表示段落的分隔&#13;
```&#13;
// 也可以用HTML中的&lt;br&gt;标签精准换行&#13;
第一段&lt;br&gt;&#13;
第二段&#13;
```&#13;
第一段&lt;br&gt;&#13;
第二段&#13;
&#13;
## 引用文字&#13;
- 引用的文本是缩进的,会具有不同字体颜色&#13;
```Markdown&#13;
这是一个引用文本&#13;
&gt; 这是一个引用文本&#13;
&gt;&gt; 多重引用&#13;
&gt;&gt;&gt; ...&#13;
```&#13;
这是一个引用文本&#13;
&gt; 这是一个引用文本&#13;
&gt;&gt; 多重引用&#13;
&gt;&gt;&gt; ....&#13;
## 引用代码&#13;
- 用多个反引号可以区分嵌套的代码 -&gt; 在隔离代码块中显示三个反引号,用四个反引号包裹&#13;
1. 单行引用 -&gt; 由单个反引号连接首尾&#13;
```Markdown&#13;
这是一个`单行引用`.&#13;
```&#13;
这是一个`单行引用`.&#13;
2. 多行引用 -&gt; 由三个反引号连接首尾&#13;
- 可以在代码块中增添语言标识符以启用语法高亮&#13;
````Markdown&#13;
以下为多行引用:&#13;
```c++&#13;
#include&lt;iostream&gt;&#13;
using namespace std;&#13;
int main()&#13;
{&#13;
    cout&lt;&lt;'Hello World!'&lt;&lt;endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
````&#13;
以下为多行引用:&#13;
&#13;
```c++&#13;
#include&lt;iostream&gt;&#13;
using namespace std;&#13;
int main()&#13;
{&#13;
    cout&lt;&lt;'Hello World!'&lt;&lt;endl;&#13;
    return 0;&#13;
}&#13;
```&#13;
## 链接&#13;
- 链接的文本是蓝色的,可以点击跳转&#13;
```Markdown&#13;
// 内联式链接 -&gt; [链接文本](链接地址)&#13;
[个人博客](https://h-txsl.github.io/Nobody_Cares.github.io/)&#13;
// 引用式链接 -&gt; [链接文本][链接标识符]&#13;
// 在文档结尾处添加链接标识符&#13;
// 链接标识符可以是任意字符串&#13;
[个人博客][blog]&#13;
&#13;
[blog]: https://h-txsl.github.io/Nobody_Cares.github.io/&#13;
```&#13;
[个人博客](https://h-txsl.github.io/Nobody_Cares.github.io/)&#13;
[个人博客][blog]&#13;
&#13;
## Markdown文档内部跳转&#13;
&#13;
```Markdown&#13;
// 标题跳转&#13;
// 跳转至设置文本样式&#13;
[设置文本样式](#设置文本样式)&#13;
&#13;
// 自定义锚点跳转&#13;
// 使用HTML的锚点标签&lt;a&gt;和id属性来实现文档内部跳转&#13;
&lt;a name='自定义标识'&gt;&lt;/a&gt;&#13;
// 跳转至设置文本样式&#13;
&#13;
[自定义锚点跳转](#user-content-set1)&#13;
&#13;
// 由于在设置文本样式处设置了锚点,所以可以直接跳转&#13;
// &lt;a name='set1'&gt;&lt;/a&gt;&#13;
// 补充: [](#这里引用的锚点全为字母小写,空格用-代替, 可以中文)&#13;
// 引用时要加上user-content-前缀&#13;
```&#13;
[设置文本样式](#设置文本样式)&#13;
[自定义锚点跳转](#user-content-set1)&#13;
- 图片链接&#13;
&gt;通过添加 ! 并 将 alt 文本用 [ ] 括起来，可显示图像。</description><guid isPermaLink="true">https://H-TXSL.github.io/Nobody_Cares.github.io/post/Markdown-yu-fa.html</guid><pubDate>Sat, 05 Oct 2024 16:02:49 +0000</pubDate></item><item><title>数据结构</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io/post/shu-ju-jie-gou.html</link><description># 数据结构&#13;
## 二叉树&#13;
### 二叉树术语 :&#13;
- 根节点(root node) : 没有父节点的节点&#13;
- 叶节点(leaf node) : 没有子节点的节点&#13;
- 边(edge) : 连接一个节点和另一个节点的线&#13;
- 节点所在层(level) : 根节点所在层为1, 根节点的子节点所在层为2, 以此类推&#13;
- 节点的度(degree) : 子节点的数量&#13;
- 二叉树的高度(height) : 从根节点到最远叶节点之间边的数量&#13;
- 节点深度(depth) : 从根节点到该节点之间边的数量&#13;
- 节点高度(height) : 从该节点到最远叶节点之间边的数量   &#13;
&#13;
### 二叉树的类型:&#13;
- 满二叉树(full binary tree) 也称 完美二叉树(perfect binary tree) : 所有节点要么没有子节点, 要么有两个子节点 &#13;
&#13;
| | 完美二叉树 |&#13;
| :--: | :--: |&#13;
| 第i层节点数 | 2^(i - 1) |&#13;
| 高度为h的树的叶节点数 | 2^h | &#13;
| 高度为h的树的节点总数 | 2^(h + 1) - 1 |&#13;
| 节点总数为n的树的高度 | log2(n + 1) - 1 |&#13;
- 完全二叉树(complete binary tree) : 只有最底层节点为被填满,且最底层节点尽量靠左填充&#13;
- 完满二叉树(full binary tree) : 除叶节点外, 所有节点都有两个子节点&#13;
- 平衡二叉树(balanced binary tree) : 所有节点的左右子树高度差不大于1&#13;
- 二叉搜索树(binary search tree) : 所有节点的左子树小于根节点, 右子树大于根节点. 左右子树也为二叉搜索树&#13;
### 二叉树遍历&#13;
- 层序遍历(level order traversal) : 从根节点开始, 从上到下, 从左到右遍历所有节点 -&gt; 时间复杂度: O(n)&#13;
```c++&#13;
// 层序遍历&#13;
void level_order(Tree* root) {&#13;
    // 创建一个队列，用于存储待访问的节点&#13;
    std::queue&lt;Tree *&gt; queue;&#13;
    // 将根节点入队&#13;
    queue.push(root);&#13;
    // 创建一个向量，用于存储遍历过程中的节点值&#13;
    std::vector&lt;int&gt; vec;&#13;
    // 遍历队列中的节点&#13;
    while (!queue.empty()) &#13;
    {&#13;
        // 取出队列的第一个节点&#13;
        Tree* node = queue.front();&#13;
        // 将节点从队列中移除&#13;
        queue.pop();&#13;
        // 将节点的值添加到向量中&#13;
        vec.push_back(node-&gt;val);&#13;
        // 如果节点有左子树，则将左子树入队&#13;
        if (node-&gt;left!= nullptr) {&#13;
            queue.push(node-&gt;left);&#13;
        }&#13;
        // 如果节点有右子树，则将右子树入队&#13;
        if (node-&gt;right!= nullptr) {&#13;
            queue.push(node-&gt;right);&#13;
        }&#13;
    }&#13;
    // 打印元素&#13;
    for (int i : vec)&#13;
    {&#13;
        std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
    }&#13;
    std::cout &lt;&lt; std::endl;&#13;
}&#13;
// 层序插入&#13;
void level_insert(Tree** root, int n) {&#13;
    // 如果根节点为空，创建一个新根节点&#13;
    if (*root == nullptr) {&#13;
        int x = rand() % 100 + 1;&#13;
        *root = new Tree(x);&#13;
    }&#13;
    std::queue&lt;Tree*&gt; queue;&#13;
    queue.push(*root);&#13;
    int count = std::pow(2, n + 1) - 1; // 修正层数计算&#13;
    int ans = count - 1;&#13;
&#13;
    // 当队列不为空且还需要插入节点时，继续循环&#13;
    while (!queue.empty() &amp;&amp; ans &gt; 0) {&#13;
        Tree* node = queue.front();&#13;
        queue.pop();&#13;
&#13;
        // 如果需要，插入左子节点&#13;
        if (node-&gt;left == nullptr &amp;&amp; ans &gt; 0) {&#13;
            int x = rand() % 100 + 1;&#13;
            node-&gt;left = new Tree(x);&#13;
            queue.push(node-&gt;left);&#13;
            ans--;&#13;
        }&#13;
&#13;
        // 如果需要，插入右子节点&#13;
        if (node-&gt;right == nullptr &amp;&amp; ans &gt; 0) {&#13;
            int x = rand() % 100 + 1;&#13;
            node-&gt;right = new Tree(x);&#13;
            queue.push(node-&gt;right);&#13;
            ans--;&#13;
        }&#13;
    }&#13;
}&#13;
```&#13;
- 前中后序遍历 -&gt; 时间复杂度: O(n)&#13;
```c++&#13;
static std::vector&lt;int&gt; vec;&#13;
// 前序遍历函数，用于遍历二叉树的前序遍历路径&#13;
void pre_order(Tree* root) {&#13;
    if (root == nullptr) {&#13;
        return;&#13;
    }&#13;
    vec.push_back(root-&gt;val);&#13;
    pre_order(root-&gt;left);&#13;
    pre_order(root-&gt;right);&#13;
}&#13;
&#13;
// 中序遍历函数，用于遍历二叉树的中序遍历路径&#13;
void in_order(Tree* root) {&#13;
    if (root == nullptr) {&#13;
        return;&#13;
    }&#13;
    in_order(root-&gt;left);&#13;
    vec.push_back(root-&gt;val);&#13;
    in_order(root-&gt;right);&#13;
}&#13;
&#13;
// 后序遍历函数，用于遍历二叉树的后序遍历路径&#13;
void post_order(Tree* root) {&#13;
    if (root == nullptr) {&#13;
        return;&#13;
    }&#13;
    post_order(root-&gt;left);&#13;
    post_order(root-&gt;right);&#13;
    vec.push_back(root-&gt;val);&#13;
}&#13;
&#13;
// 深度优先搜索函数，用于遍历二叉树的前序、中序和后序遍历路径&#13;
void dfs(Tree* root) {&#13;
    std::cout &lt;&lt; '前序遍历' &lt;&lt; ' ';&#13;
    pre_order(root);&#13;
    dfs_print();&#13;
    std::cout &lt;&lt; std::endl;&#13;
    std::cout &lt;&lt; '中序遍历' &lt;&lt; ' ';&#13;
    in_order(root);&#13;
    dfs_print();&#13;
    std::cout &lt;&lt; std::endl;&#13;
    std::cout &lt;&lt; '后序遍历' &lt;&lt; ' ';&#13;
    post_order(root);&#13;
    dfs_print();&#13;
    std::cout &lt;&lt; std::endl;&#13;
}&#13;
```&#13;
### 二叉树的数组表示&#13;
&gt; 完全二叉树非常适合用数组表示, None只会出现在最底层且靠右的位置,所以层序遍历之后None全在末尾, 可以直接省略&#13;
```c++&#13;
class Binary_Tree_Array&#13;
{&#13;
    public:&#13;
    Binary_Tree_Array(std::vector&lt;int&gt; arr) {&#13;
        tree_ = arr;&#13;
    } &#13;
    ~Binary_Tree_Array() {}&#13;
    // 获取容量&#13;
    int size() {&#13;
        return tree_.size();&#13;
    }&#13;
    // 获取索引为i的值&#13;
    int val(int i) {&#13;
        if (i &lt; 0 || i &gt; size()) {&#13;
            return INT_MAX;&#13;
        }&#13;
        return tree_[i];&#13;
    }&#13;
    // 获取索引为i的左子节点索引&#13;
    int left(int i) {&#13;
        return 2 * i + 1;&#13;
    }&#13;
    // 获取索引为i的右子节点索引&#13;
    int right(int i) {&#13;
        return 2 * i + 2;&#13;
    }&#13;
    // 获取索引为i的父节点索引&#13;
    int parent(int i) {&#13;
        return (i - 1) / 2;&#13;
    }&#13;
    // 层序遍历&#13;
    void level_order() {&#13;
        if (!tree_.empty()) {&#13;
            for (int i : tree_)&#13;
            {&#13;
                std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
            }&#13;
            std::cout &lt;&lt; std::endl;&#13;
        }&#13;
    }&#13;
    // 前中后序遍历&#13;
    void pre_order() {&#13;
        std::vector&lt;int&gt; vec_;&#13;
        dfs(0, 'pre', vec_);&#13;
        std::cout &lt;&lt; 'pre : ';&#13;
        for (int i : vec_) &#13;
        {&#13;
            if (i != INT_MAX) {&#13;
                std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
            }&#13;
        }&#13;
        std::cout &lt;&lt; std::endl;&#13;
    }&#13;
    void in_order() {&#13;
        std::vector&lt;int&gt; vec_;&#13;
        dfs(0, 'in', vec_);&#13;
        std::cout &lt;&lt; 'in : ';&#13;
        for (int i : vec_) &#13;
        {&#13;
            if (i != INT_MAX) {&#13;
                std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
            }&#13;
        }&#13;
        std::cout &lt;&lt; std::endl;&#13;
    }&#13;
    void post_order() {&#13;
        std::vector&lt;int&gt; vec_;&#13;
        dfs(0, 'post', vec_);&#13;
        std::cout &lt;&lt; 'post : ';&#13;
        for (int i : vec_) &#13;
        {&#13;
            if (i != INT_MAX) {&#13;
                std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
            }&#13;
        }&#13;
        std::cout &lt;&lt; std::endl;&#13;
    }&#13;
    private:&#13;
    std::vector&lt;int&gt; tree_;&#13;
    void dfs(int i, std::string order, std::vector&lt;int&gt; &amp;vec_) {&#13;
        if (val(i) == INT_MAX) {&#13;
            return;&#13;
        }&#13;
        if (order == 'pre') {&#13;
            vec_.push_back(val(i));&#13;
        }&#13;
        dfs(left(i), order, vec_);&#13;
        if (order == 'in') {&#13;
            vec_.push_back(val(i));&#13;
        }&#13;
        dfs(right(i), order, vec_);&#13;
        if (order == 'post') {&#13;
            vec_.push_back(val(i));&#13;
        }&#13;
    }&#13;
};&#13;
```&#13;
### 二叉搜索树&#13;
- 插入 : 时间复杂度: O(logn)&#13;
- 查找 : 时间复杂度: O(logn)&#13;
- 删除 : 时间复杂度: O(logn)&#13;
+ 二叉搜索树的中序遍历是升序的&#13;
&gt; 二叉搜索树删除操作完成后需保持二叉搜索树的性质'左子树 &lt; 根节点 &lt; 右子树'&#13;
&gt; 删除操作根据节点的度分为 0, 1, 2 三种情况&#13;
&gt; 节点度为0 : 直接删除&#13;
&gt; 节点度为1 : 将待删节点替换为待删节点的子节点&#13;
&gt; 节点度为2 : 找到左子树的最大节点或右子树的最小节点,标记该节点, 再删除左子树的最大节点或右子树的最小节点, 再将待删节点替换为标记节点&#13;
```c++&#13;
// 二叉搜索树&#13;
class Binary_Search_Tree&#13;
{&#13;
    public:&#13;
    // 插入&#13;
    void insert(int num) {&#13;
        if (tree_ == nullptr) {&#13;
            tree_ = new Tree(num);&#13;
            return;&#13;
        }&#13;
        Tree *cur = tree_, *pre = nullptr;&#13;
        // 循环查找插入位置&#13;
        while (cur != nullptr) &#13;
        {&#13;
            if (cur-&gt;val == num) {&#13;
                return;&#13;
            }&#13;
            // 记录上一个节点&#13;
            pre = cur;&#13;
            if (cur-&gt;val &lt; num) {&#13;
                cur = cur-&gt;right;&#13;
            } else {&#13;
                cur = cur-&gt;left;&#13;
            }&#13;
        }&#13;
        // 插入节点&#13;
        Tree* node = new Tree(num);&#13;
        if (pre-&gt;val &lt; num) {&#13;
            pre-&gt;right = node;&#13;
        } else {&#13;
            pre-&gt;left = node;&#13;
        }&#13;
    }&#13;
    // 查找节点&#13;
    Tree* search(int num) {&#13;
        if (tree_ == nullptr) {&#13;
            std::cout &lt;&lt; '无节点' &lt;&lt; std::endl;&#13;
            return nullptr;&#13;
        }&#13;
        Tree* cur = tree_;&#13;
        while (cur != nullptr)&#13;
        {&#13;
            if (cur-&gt;val == num) {&#13;
                return cur;&#13;
            }&#13;
            if (cur-&gt;val &gt; num) {&#13;
                cur = cur-&gt;left;&#13;
            } else {&#13;
                cur = cur-&gt;right;&#13;
            }&#13;
        }&#13;
        std::cout &lt;&lt; '无节点' &lt;&lt; std::endl;&#13;
        return nullptr;&#13;
    }&#13;
    // 删除节点&#13;
    void remove(int num) {&#13;
        // 根节点为空&#13;
        if (tree_ == nullptr) {&#13;
            return;&#13;
        }&#13;
        Tree* cur = tree_, *pre = nullptr;&#13;
        while (cur != nullptr)&#13;
        {&#13;
            // 找待删节点&#13;
            if (cur-&gt;val == num) {&#13;
                break;&#13;
            }&#13;
            pre = cur;&#13;
            if (cur-&gt;val &gt; num) {&#13;
                cur = cur-&gt;left;&#13;
            } else {&#13;
                cur = cur-&gt;right;&#13;
            }&#13;
        }&#13;
        // 无删除节点&#13;
        if (cur == nullptr) {&#13;
            return;&#13;
        }&#13;
        // 删除节点的度为 0 或 1&#13;
        if (cur-&gt;left == nullptr || cur-&gt;right == nullptr) {&#13;
            // 节点的度为 0 / 1, node = nullpre / 子节点&#13;
            Tree* node = cur-&gt;left != nullptr ? cur-&gt;left : cur-&gt;right;&#13;
            // 是否为根节点&#13;
            if (cur != tree_) {&#13;
                // 左接左,右接右&#13;
                if (pre-&gt;left == cur) {&#13;
                    pre-&gt;left = node;&#13;
                } else {&#13;
                    pre-&gt;right = node;&#13;
                }&#13;
            } else {&#13;
                // 若为根节点,则重新指定根节点&#13;
                tree_ = node;&#13;
            }&#13;
            delete cur;&#13;
        } // 删除节点的度为 2&#13;
        else {&#13;
            // // 右树的最小节点&#13;
            // Tree* min_node = cur-&gt;right;&#13;
            // while (min_node-&gt;left != nullptr)&#13;
            // {&#13;
            //     min_node = min_node-&gt;left;&#13;
            // }&#13;
            // int temp_val = min_node-&gt;val;&#13;
            // // 递归删除&#13;
            // remove(temp_val);&#13;
            // cur-&gt;val = temp_val;&#13;
&#13;
            // 左树的最大节点&#13;
            Tree* max_node = cur-&gt;left;&#13;
            while (max_node-&gt;right != nullptr)&#13;
            {&#13;
                max_node = max_node-&gt;right;&#13;
            }&#13;
            int temp_val = max_node-&gt;val;&#13;
            remove(temp_val);&#13;
            cur-&gt;val = temp_val;&#13;
        }&#13;
    }&#13;
    void bst_print() {&#13;
        std::vector&lt;int&gt; vec;&#13;
        in_order(vec, tree_);&#13;
        for (int i : vec) &#13;
        {&#13;
            std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
        }&#13;
        std::cout &lt;&lt; std::endl;&#13;
    }&#13;
    // 中序遍历&#13;
    void in_order(std::vector&lt;int&gt;&amp; v, Tree* root) {&#13;
        if (root == nullptr) {&#13;
            return;&#13;
        }&#13;
        in_order(v, root-&gt;left);&#13;
        v.push_back(root-&gt;val);&#13;
        in_order(v, root-&gt;right);&#13;
    }&#13;
    private:&#13;
    Tree* tree_ = nullptr;&#13;
};&#13;
```&#13;
### AVL树&#13;
- AVL树即是二叉搜索树又是平衡二叉树,同时满足两类二叉树的性质,是一种平衡二叉搜索树.&#13;
- AVL树的相关操作需要获取节点高度,所有在节点中需要添加高度属性&#13;
- AVL树的插入和删除操作需更新节点高度, 并调整平衡因子.自底向上执行旋转操作,使失衡因子恢复平衡.&#13;
- 节点高度: 节点到叶子节点的最长路径长度. 叶子节点高度为 0, 空节点高度为 -1.&#13;
- 平衡因子 : 节点左子树高度 - 节点右子树高度. 空节点平衡因子为 0.&#13;
&gt; 设平衡因子为f, 则平衡二叉树的平衡因子的绝对值不大于1, 即 |f| &lt;= 1.&#13;
&gt; 节点的平衡因子的绝对值 &gt; 1的节点为'失衡节点'.&#13;
&gt;&#13;
以下为AVL树的相关操作&#13;
```c++&#13;
// AVL树节点&#13;
struct TreeNode&#13;
{&#13;
    int val{};&#13;
    int height = 0; // 节点高度&#13;
    TreeNode *left{};&#13;
    TreeNode *right{};&#13;
    TreeNode() = default;&#13;
    explicit TreeNode(int x) : val(x){}&#13;
};&#13;
class AVL_Tree&#13;
{&#13;
    public:&#13;
    AVL_Tree() {&#13;
        root = nullptr;&#13;
    }&#13;
    AVL_Tree(TreeNode* node) {&#13;
        root = node;&#13;
    }&#13;
    ~AVL_Tree() {}&#13;
        // 获取节点高度&#13;
    int height(TreeNode* node) {&#13;
        return node == nullptr ? -1 : node-&gt;height;&#13;
    }&#13;
    // 更新节点高度&#13;
    void up_data_height(TreeNode* node) {&#13;
        node-&gt;height = std::max(height(node-&gt;left), height(node-&gt;right)) + 1;&#13;
    }&#13;
    // 获取平衡因子&#13;
    int balance_factor(TreeNode* node) {&#13;
        // 空节点平衡因子为 0&#13;
        if (node == nullptr) {&#13;
            return 0;&#13;
        }&#13;
        // 节点平衡因子 = 左子树高度 - 右子树高度&#13;
        return height(node-&gt;left) - height(node-&gt;right);&#13;
    }&#13;
    // 右旋&#13;
    TreeNode* right_rotate(TreeNode* node) {&#13;
        TreeNode* child = node-&gt;left;&#13;
        TreeNode* grand_child = child-&gt;right;&#13;
        // 以child为原点,将node右旋&#13;
        child-&gt;right = node;&#13;
        node-&gt;left = grand_child;&#13;
        // 更新节点高度&#13;
        up_data_height(node);&#13;
        up_data_height(child);&#13;
        // 返回旋转后子树根节点&#13;
        return child;&#13;
    }&#13;
    // 左旋&#13;
    TreeNode* left_rotate(TreeNode* node) {&#13;
        TreeNode* child = node-&gt;right;&#13;
        TreeNode* grand_child = child-&gt;left;&#13;
        // 以child为原点,将node左旋&#13;
        child-&gt;left = node;&#13;
        node-&gt;right = grand_child;&#13;
        // 更新节点高度&#13;
        up_data_height(node);&#13;
        up_data_height(child);&#13;
        return child;&#13;
    }&#13;
    // 旋转操作&#13;
    TreeNode* rotate(TreeNode* node) {&#13;
        // 获取节点node的平衡因子&#13;
        int node_balance_factor = balance_factor(node);&#13;
        // 左偏树&#13;
        if (node_balance_factor &gt; 1) {&#13;
            if (balance_factor(node-&gt;left) &gt;= 0) {&#13;
                // 右旋&#13;
                return right_rotate(node);&#13;
            } else {&#13;
                // 先左旋后右旋&#13;
                node-&gt;left = left_rotate(node-&gt;left);&#13;
                return right_rotate(node);&#13;
            }&#13;
        }&#13;
        // 右偏树&#13;
        if (node_balance_factor &lt; -1) {&#13;
            if (balance_factor(node-&gt;right) &lt;= 0) {&#13;
                // 左旋&#13;
                return left_rotate(node);&#13;
            } else {&#13;
                // 先右旋后左旋&#13;
                node-&gt;right = right_rotate(node-&gt;right);&#13;
                return left_rotate(node);&#13;
            }&#13;
        }&#13;
        // 平衡树,无需旋转&#13;
        return node;&#13;
    }&#13;
    // 插入节点&#13;
    void insert(int val) {&#13;
        root =  insert_helper(root, val);&#13;
    }&#13;
    // 递归插入&#13;
    TreeNode* insert_helper(TreeNode* node, int val) {&#13;
        // 空节点,直接构造&#13;
        if (node == nullptr) {&#13;
            return new TreeNode(val);&#13;
        } &#13;
        // 寻找正确插入点&#13;
        if (val &lt; node-&gt;val) {&#13;
            node-&gt;left = insert_helper(node-&gt;left, val);&#13;
        } else if (val &gt; node-&gt;val) {&#13;
            node-&gt;right = insert_helper(node-&gt;right, val);&#13;
        } else {&#13;
            // 有重复节点直接返回&#13;
            return node;&#13;
        }&#13;
        // 更新节点高度&#13;
        up_data_height(node);&#13;
        // 执行旋转操作,使该子树重新恢复平衡&#13;
        node = rotate(node);&#13;
        // 返回根节点&#13;
        return node;&#13;
    }&#13;
    // 删除节点&#13;
    void remove(int val) {&#13;
        root = remove_helper(root, val);&#13;
    }&#13;
    // 递归删除&#13;
    TreeNode* remove_helper(TreeNode* node, int val) {&#13;
        if (node == nullptr) {&#13;
            return nullptr;&#13;
        }&#13;
        // 寻找节点删除&#13;
        if (val &lt; node-&gt;val) {&#13;
            node-&gt;left = remove_helper(node-&gt;left, val);&#13;
        } else if (val &gt; node-&gt;val) {&#13;
            node-&gt;right = remove_helper(node-&gt;right, val);&#13;
        } else {&#13;
            if (node-&gt;left == nullptr || node-&gt;right == nullptr) {&#13;
                // 子节点数量为 0/1 的情况&#13;
                TreeNode* child = node-&gt;left != nullptr ? node-&gt;left : node-&gt;right;&#13;
                if (child == nullptr) {&#13;
                    // 子节点为 0, 直接删除&#13;
                    delete node;&#13;
                    return nullptr;&#13;
                } else {&#13;
                    // 子节点为 1, 删除并替换&#13;
                    delete node;&#13;
                    node = child;&#13;
                }&#13;
            } else {&#13;
                // 子节点数量为 2 的情况&#13;
                // 用左子树最大值节点替换&#13;
                TreeNode* left_child = node-&gt;left;&#13;
                // 找最大值节点&#13;
                while (left_child-&gt;right != nullptr) &#13;
                {&#13;
                    left_child = left_child-&gt;right;&#13;
                }&#13;
                int max_val = left_child-&gt;val;&#13;
                // 递归删除左子树的最大值节点&#13;
                node-&gt;left = remove_helper(node-&gt;left, max_val);&#13;
                // 值替换&#13;
                node-&gt;val = max_val;&#13;
                // // 用右子树最小值节点替换&#13;
                // TreeNode* right_child = node-&gt;right;&#13;
                // while (right_child-&gt;left != nullptr) &#13;
                // {&#13;
                //     right_child = right_child-&gt;left;&#13;
                // }&#13;
                // int min_val = right_child-&gt;val;&#13;
                // node-&gt;right = remove_helper(node-&gt;right, min_val);&#13;
                // node-&gt;val = min_val;&#13;
            }&#13;
        }&#13;
        // 更新节点高度&#13;
        up_data_height(node); &#13;
        // 执行旋转操作,使该子树平衡&#13;
        node = rotate(node);&#13;
        // 返回根节点&#13;
        return node;&#13;
    }&#13;
    // 打印&#13;
    void AVL_print() {&#13;
        // vec存储节点的平衡因子&#13;
        std::vector&lt;int&gt; vec;&#13;
        in_order(root, vec);&#13;
        std::cout &lt;&lt; std::endl;&#13;
        for (int i : vec) &#13;
        {&#13;
            std::cout &lt;&lt; i &lt;&lt; ' ';&#13;
        }&#13;
        std::cout &lt;&lt; std::endl;&#13;
    }&#13;
    void in_order(TreeNode* node, std::vector&lt;int&gt;&amp; v) {&#13;
        if (node == nullptr) {&#13;
            return;&#13;
        } &#13;
        in_order(node-&gt;left, v);&#13;
        std::cout &lt;&lt; node-&gt;val &lt;&lt; ' ';&#13;
        v.push_back(balance_factor(node));&#13;
        in_order(node-&gt;right, v);&#13;
    }&#13;
    private:&#13;
    TreeNode* root;&#13;
};&#13;
```&#13;
#### AVL树的旋转操作&#13;
- AVL树的旋转操作分为四种: 左旋, 右旋, 先左旋后右旋, 先右旋后左旋.&#13;
- 左右旋为对称操作&#13;
1. 左旋&#13;
&lt;img width='504' alt='image' src='https://github.com/user-attachments/assets/363d2ae0-2ac1-4307-9116-25d29ad1d6ee'&gt;&#13;
&#13;
```c++&#13;
// 左旋&#13;
    TreeNode* left_rotate(TreeNode* node) {&#13;
        TreeNode* child = node-&gt;right;&#13;
        TreeNode* grand_child = child-&gt;left;&#13;
        // 以child为原点,将node左旋&#13;
        child-&gt;left = node;&#13;
        node-&gt;right = grand_child;&#13;
        // 更新节点高度&#13;
        up_data_height(node);&#13;
        up_data_height(child);&#13;
        return child;&#13;
    }&#13;
```&#13;
2. 右旋&#13;
&lt;img width='513' alt='image' src='https://github.com/user-attachments/assets/eb351226-65e4-4259-83b7-d221bcfe00f0'&gt;&#13;
&#13;
```c++&#13;
// 右旋&#13;
    TreeNode* right_rotate(TreeNode* node) {&#13;
        TreeNode* child = node-&gt;left;&#13;
        TreeNode* grand_child = child-&gt;right;&#13;
        // 以child为原点,将node右旋&#13;
        child-&gt;right = node;&#13;
        node-&gt;left = grand_child;&#13;
        // 更新节点高度&#13;
        up_data_height(node);&#13;
        up_data_height(child);&#13;
        // 返回旋转后子树根节点&#13;
        return child;&#13;
    }&#13;
```&#13;
3. 先左旋后右旋&#13;
&lt;img width='587' alt='image' src='https://github.com/user-attachments/assets/a7457929-6867-408e-82bf-add2f6d9aacf'&gt;&#13;
&#13;
4. 先右旋后左旋&#13;
&lt;img width='531' alt='image' src='https://github.com/user-attachments/assets/30cdfb04-2ba0-423c-b1f8-c512f45ab126'&gt;&#13;
&#13;
- 通过AVL树的不用情况选择不同的旋转操作,使树重新恢复平衡.&#13;
以下为封装的旋转操作函数&#13;
```c++&#13;
// 旋转操作&#13;
    TreeNode* rotate(TreeNode* node) {&#13;
        // 获取节点node的平衡因子&#13;
        int node_balance_factor = balance_factor(node);&#13;
        // 左偏树&#13;
        if (node_balance_factor &gt; 1) {&#13;
            if (balance_factor(node-&gt;left) &gt;= 0) {&#13;
                // 右旋&#13;
                return right_rotate(node);&#13;
            } else {&#13;
                // 先左旋后右旋&#13;
                node-&gt;left = left_rotate(node-&gt;left);&#13;
                return right_rotate(node);&#13;
            }&#13;
        }&#13;
        // 右偏树&#13;
        if (node_balance_factor &lt; -1) {&#13;
            if (balance_factor(node-&gt;right) &lt;= 0) {&#13;
                // 左旋&#13;
                return left_rotate(node);&#13;
            } else {&#13;
                // 先右旋后左旋&#13;
                node-&gt;right = right_rotate(node-&gt;right);&#13;
                return left_rotate(node);&#13;
            }&#13;
        }&#13;
        // 平衡树,无需旋转&#13;
        return node;&#13;
    }&#13;
```&#13;
#### AVL树旋转的选择&#13;
| 失衡节点的平衡因子 | 子节点的平衡因子 | 应采用的旋转操作 |&#13;
| :--: | :--: | :--: |&#13;
| &gt; 1(左偏树) | &gt;= 0 | 右旋 |&#13;
| &gt; 1(左偏树) | &lt; 0 | 先左旋后右旋 |&#13;
| &lt; -1(右偏树) | &lt;= 0 | 左旋 |&#13;
| &lt; -1(右偏树) | &gt; 0 | 先右旋后左旋 |&#13;
&#13;
。</description><guid isPermaLink="true">https://H-TXSL.github.io/Nobody_Cares.github.io/post/shu-ju-jie-gou.html</guid><pubDate>Fri, 04 Oct 2024 16:35:57 +0000</pubDate></item><item><title>个人博客部署</title><link>https://H-TXSL.github.io/Nobody_Cares.github.io/post/ge-ren-bo-ke-bu-shu.html</link><description># 个人博客快速搭建&#13;
&#13;
- 此博客直接部署与github上,直接通过以下项目模板创建.&#13;
  [Meekdai/Gmeek: Gmeek is a Blog All in Github](https://github.com/Meekdai/Gmeek)&#13;
&#13;
# 配置文件&#13;
&#13;
- 配置`config.json`文件&#13;
  &#13;
  ```c++&#13;
  {&#13;
  'title':'Meekdai',  // 博客名&#13;
  'subTitle':'童话是一种生活态度，仅此而已。</description><guid isPermaLink="true">https://H-TXSL.github.io/Nobody_Cares.github.io/post/ge-ren-bo-ke-bu-shu.html</guid><pubDate>Sat, 17 Aug 2024 13:22:43 +0000</pubDate></item></channel></rss>